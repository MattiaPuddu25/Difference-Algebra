########################################################################
########################################################################
## GOAL: TO COMPUTE THE MULTIPLICATIVE VARIABLES SETS FOR EACH ELEMENT OF A SET OF MONOMIALS
##     - STEPS
##  1) Generate the semi-group generated by the morphisms in the difference polynomial ring
##  2) Work on this semi-group element by element
########################################################################
########################################################################
function multiplicative_variables_monomial(M::Vector{Vector{Int64}})
    ## We identify a monomial x_1^(a_1)*...*x_l^(a_l) with the vector [a_1,...,a_l]
    ## We have a vector M = [m_1,...m_n] of monomials, we compute the multiplicative variables for of each m_i in M; the function returns a vector L of integer vectors:
    ## The integer vector L[i] has 1 in position j if x_j is a multiplicative variable for m_i

        ## CHECK: THE MONOMIALS MUST ALL HAVE WRITTEN WITH THE SAME NUMBER OF VARIABLES
    t = [length(M[k]) for k in 1:length(M)];
    if minimum(t)!=maximum(t)
        return print("error: the vectors representing the monomials are not all of the same length")
    end

    n = length(M)                           # number of monomials
    l = length(M[1])                        # number of indeterminates
    L = [ones(Int64, l) for _ in 1:n];      # initialize the vectors of multiplicative variables

    if n == 1                               # if there is only one monomial, every variable is a multiplicative variable!
        return L
    end

    a = maximum([M[l][1]] for l in 1:n)[1]  # maximum exponent of the first variable in all monomials

    if l == 1                               # only one variable: it is multiplicative for a monomial only if it appears with maximum exponent
        for i in 1:n
            if a > M[i][1]
                L[i][1] = 0;
            end
        end
        return L
    end

    ######################### NOW WE HAVE AT LEAST TWO MONOMIALS WITH AT LEAST TWO VARIABLES
    for i in 1:n
        ## we check as before the first variable
        if a > M[i][1]
                    L[i][1] = 0;
        end
        
        ## we check the other variables for m_i; for the variable x_j we need to consider the monomials having the same exponents as m_i in the first j-1 variables
        for j in 2:l
            u = M[i][1:j-1];
            S = [v for v in M if v[1:j-1]==u];

            if M[i][j] < maximum(v[j] for v in S)
                L[i][j] = 0;
            end
        end
    end

    return L
end
########################################################################
########################################################################
function decompose(M::Vector{Vector{Int64}})                    ## Analogue of Algorithm 2.1.6 in Robertz' book. Here I am assuming fixed the ordering on the variables,
                                                                ## since I am using an ordered vector; namely, x_1<x_2<...<x_l
    n = length(M)                           # number of monomials
    l = length(M[1])                        # number of indeterminates
    
    initial = [[v,ones(Int64,l)] for v in M];
    if length(M)<=1
        return initial
    end
## USARE I SET
    m = [maximum(v[i] for v in M) for i in 1:l]
    y = argmax(m .* (m .!= 0));

    for i in 1:y

    end
    print("OK")
end


function is_Janet_complete_monomial(M::Vector{Vector{Int64}})
### M is Janet_complete iff the 

    L = multiplicative_variables_monomial(M);

    n = length(M)                           # number of monomials
    l = length(M[1])                        # number of indeterminates
    ## It is convenient to reduce: if gcd(M)!=1, we can subtract the contributes of the gcd
        GCD = [minimum(v[i] for v in M) for i in 1:l];
        M_new = [[v[i] - GCD[i] for i in 1:l] for v in M];          ## It has the same vectors of multiplicative variables of M
    if n == 1
        return true
    end 
    

return false
end







########################################################################
########################################################################
# Computes the set of multiplicative variables for each element of a monomials
function multiplicative_variables(F::Vector{DifferencePolyRingElem{QQFieldElem}})
    # Need to check that each element of F is a monomial!            # F=[y_1*y_2, y_1^3*y_2]
    n = length(F);                                                  # n=2
    m = n_action_maps(R);                                           # m=2
    M = [];
    
    if n == 1
        return elementary_symbols(R)
    end

#    for i in 1:n
#        for j in 1:m
#        if F[1][1]>
#             for j in 1:m
#            
#         end
#    end
#    return M
end

# LATER function multiplicative_variables(F::Vector{DifferencePolyRingElem{QQFieldElem}})











##################
##EXAMPLES

v = 2;                                                                  # number of variables
e = 2;                                                                  # number of morphisms

R, (y_1,y_2) = difference_polynomial_ring(QQ, v, e);
set_ranking!(R, partition=[[0,1],[1,0]], index_ordering_name=:deglex)
n=4;
f_1 = diff_action(y_1, [0,1])^2+1;
f_2 = diff_action(y_1, [2,0])+diff_action(y_2,[0,1]);
f_3 = diff_action(y_1, [0,1])*diff_action(y_2,[0,2]);
f_4 = diff_action(y_1, [1,1])^2-diff_action(y_1,[1,0])^4;
F=[f_1,f_2,f_3,f_4];
mu_1 = [[0,1]]
mu_2 = [[1,0],[0,1]]
mu_3 = [[1,0],[0,1]]
mu_4 = [[0,1]]

f = diff_action(y_2,[1,1])*diff_action(y_2,[0,3])-diff_action(y_1,[2,0]);
g = diff_action(y_1,[3,0])-diff_action(y_2,[0,3])+(diff_action(y_1,[0,1]))^2;

r = f;
b = 1;

M=[[1, 0, 2, 3],[2, 0, 1, 4], [1, 0, 2, 5], [1, 1, 1, 3], [2, 0, 2, 6], [2, 0, 1, 3]];